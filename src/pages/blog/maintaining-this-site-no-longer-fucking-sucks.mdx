
import { ArticleLayout } from '@/components/ArticleLayout'
import Image from 'next/image'
import Link from 'next/link'

import NextJSErrors from '@/images/next-js-errors.png'

export const meta = {
  author: "Zachary Proser",
  date: "2023-04-27",
  title: "Maintaining this site no longer fucking sucks",
  description: "After re-doing my personal website in next.js and deploying to Vercel, I reflect on how much better the developer experience has become.",
  image: "wakka.png", 
}

export default (props) => <ArticleLayout meta={meta} {...props} />

Recently I wrote about how maintaining the last generation of my personal portfolio site <Link href="/blog/maintaining-this-site-fucking-sucks">absolutely FUCKING SUCKED</Link>, and how that was an amazing opportunity for me to constantly try out good and bad ways of doing things. 

I've also written about how I like to redo my entire site every few years in order to keep my skills sharp and keep tabs on what's possible. 

I'm happy to share that I've just now (the last week of April 2023), finished redoing my site again to the current incarnation you are reading right now. 

## The latest stack 

* Next.js 13.3
* Tailwind css & Tailwind UI 
* Vercel for framework defined infrastructure and deployment

## Why keep doing this to myself?

These are the main reasons I wanted to redo my site. The primary one was dependency hell. I was far behind on Vue 2 and nuxt 2 and had not really kept up with breaking changes across the projects. It's an old story, but the further behind I fell, the harder it was to keep up. 

Everytime I wanted to quicky pop back to my site after a long absence to fire off a quick blog post (something that sounds like it should be relatively easy) I ended up wrestling with the various C packages needed to compile my SASS to CSS. Yikes. 

Meanwhile, I was also curious to try out the latest to see how all the various projects and develop tooling had come since I last went all in on a node based framework for building a personal blog. In the previous iteration of my site, I had sort of arrived at an enhanced markdown system, where I read markdown files, parsed their frontmatter metadata to handle routing and display categories, fetched their data asynchronously and ran it through several plugins like `prism` in order to support code syntax highlighting and other rendering features and then renderied it for the viewer. 

In skimming the docs for next.js and MDX, it appeared the project now supported that functionality and more out of the box with a nicer integration and less gross config required. In addition, it seemed that many rust-based tools to support key parts of the developer experience had replaced slower predecessors. I was intrigued enough to give it a shot. 

Finally, while I've done projects in React and Vue over the years, I wanted to take a crack at managing my personal site in React. And while I've been a happy Bootstrap user for many years now, I also wanted to break out of my comfort zone and give Tailwind CSS and Tailwind UI a shot. 

The results are the site you are currently reading!

### Even as a grumpy developer,  I was pleasantly surprised:
Why? Error reporting is light-years better than I ever remember it being for frontend development. 

<Image src={NextJSErrors} alt="Next.js errors are pleasant to work with and human-legible" />

The errors were human legible and I experienced very few WTF moments throughout a weekend of furious hacking. This is some of the highest ratio of time spent just building features and shipping content versus wrestling with my tooling and debugging why something simple isn't working. 

Hot reloading feels much improved over the years.  

It feels like I stepped away for a couple years and then many of the UX pain points for developing on the frontend were handily resolved

The way next.js handles things like fonts, prism for code highlighting which even supports custom themes (I installed gruvbx for my site because it is the only correct choice) and MDX integration out of the box is exactly how I wanted to work with my blog content, because markdown is easy to maintain and quick to write, but I can now also render rich graphs or media to enrich my content. 

For example, here's a look at how easy it is to load a custom Google Font in a next.js project: 

```jsx
// pages/_app.js
import { Inter } from 'next/font/google'

// If loading a variable font, you don't need to specify the font weight
const inter = Inter({ subsets: ['latin'] })

export default function MyApp({ Component, pageProps }) {
  return (
    <main className={inter.className}>
      <Component {...pageProps} />
    </main>
  )
}

```

More importantly, the optimization happens server-side - and a request is *never sent to Google* when someone hits your site. This is fantastic. It took me quite literally 30 seconds to throw up a branch with a pull request to review what it would look like to change my site back to the custom Google Font Oxygen I've used in the past. 

I was able to quickly eyeball the two fonts together side by side and decide I wanted to stick with the default. Again, the speed of iteration is profound. 

These speed gains just continue when you consider using MDX - which is "markdown for the component era" which allows you to load `.jsx` in your markdown.

Here's a quick snippet to show what I mean. For the most part, it's still just markdown, but now you can build and import rich graphs and diagrams, images, gifs (which I use for terminal demos on my site), and much more: 

```jsx
import { ArticleLayout } from '@/components/ArticleLayout'
import Image from 'next/image'
import HeroImage from './symfony-optimizer-splash.png'
import ExampleReport from './article-optimizer-example-report.png'

export const meta = {
  author: 'Zachary Proser',
  date: '2022-07-14',
  title: 'A powerful and open source content optimizer',
  description: 'A full technical deep-dive on my optimizer app and its features',
  image: 'optimizer-blog.png'
}

export default (props) => <ArticleLayout meta={meta} {...props} />

<Image src={HeroImage} />

## Overview

This post will walk through my open-sourced Article Optimizer app...
```


I can think of a number of proejcts over the past years this would have significantly simplified. 

To underscore the previous point, I was able to have the majority of my previous site and blog migrated to my Tailwind UI template site in a single weekend. Once I had tweaked the template to my needs, I was mostly moving markdown in place, rewriting image links and adding some MDX / react preamble to my markdown files, which otherwise did not need to change. This was one of the least painful migrations I've done. 

### React is pretty fast, as is - everything else...

The git integration with Vercel is excellent just as it is with Netlify. It allows for very rapid iterate, preview, deploy cycles. I literally built a working landing page with a form component by composing some components I already had, then successful deployed it to a preview environment, verified it, and deployed it to master within 13 minutes - while having a conversation with someone. This is a testament to this tooling and all the work that has gone into making the developer experience excellent 

At long last, I may have settled on a personal preference for React. Something about it clicked enough where it felt natural to express, and easy to reuse my UI components 

### The backend API handling is really nice once you grok it 

Again, speaking from the perspective of speed of iteration and rapid deployment, the next.js API integration / backend function generation stuff is actually really nice. Imagine you have a form that needs to capture emails from your blog subscribers and send it on to a third party service to subscribe the new reader to your list. 

Next.js uses the concept of Pages, which are React components exported from [`.js`, `.jsx`, `.ts`, `tsx`] files. For example, if you create `pages/about.js`, then that React component will be available at `/about`. This allows for very rapid iteration once you understand this, and you can easily re-use components across pages to keep your code dry but still build very quickly. 

But where do you put the form handling backend code? And how can you securely process values in your backend form while still open-sourcing your entire site? 

For API handling, Next.js allows you to add code to `pages/api/<blah.js>` .  For example, the following code, written in `pages/api/user.js` would return  a JSON response representing the user when you git `/api/user`
```jsx
export default function handler(req, res) {
  res.status(200).json({ name: 'John Doe' })
}
```
Any code you write here needs to satisfy the interface demonstrated above, of a function accepting a request and a response object. 

So what does Next.js / Vercel do with code you write in `pages/api/`? it converts it to a lambda essentially, or a Vercel function, which you can easily view the logs for in the Vercel dashboard or via the CLI. 

And when you develop locally? Well then next.js just runs your function locally so you can see `console.log` output in the same terminal where you ran `npm run dev`. 

All this means that you can write frontend and backend code in an organized way in a single repository, have an outstanding experience running it locally and in production, and still handle secrets via environment variables so that you never check anything sensitive into version control. 

Here's the form processing code for my simple email subscribe form:

```jsx
port default async function handler(req, res) {
  // Get data submitted in request's body.
  const body = req.body

  // if email is missing, return an error 
  if (body.email == "") {
    res.status(400).json({ data: `Error: no valid email found in request`})
  }
  // Read the secrets (API Key and List ID) out of Vercel environment variables
  const emailOctopusAPIKey = process.env.EMAIL_OCTOPUS_API_KEY
  const emailOctopusListId = process.env.EMAIL_OCTOPUS_LIST_ID
  const newMemberEmailAddress = body.email
  const emailOctopusAPIEndpoint = `https://emailoctopus.com/api/1.6/lists/${emailOctopusListId}/contacts`

  const data = {
    api_key: emailOctopusAPIKey, 
    email_address: newMemberEmailAddress,
    status: "SUBSCRIBED"
  } 

  const requestOptions = {
    crossDomain: true, 
    method: 'POST', 
    headers: {'Content-type':'application/json'}, 
    body: JSON.stringify(data)
  }

  const response = await fetch(emailOctopusAPIEndpoint, requestOptions)
    .then((response) => response.json())
    .then((data) => console.dir(data))
    .catch((error) => console.dir(error))

  // Sends a HTTP success code
  res.status(200).json({ data: `Think we successfully subscribed ${body.email}` })
}
```


### What does this all mean together? Next.js is fast - stupidly fast - to work with

When you combine all the previous points you can start to see how you could rapidly build and easily maintain many high quality and performant sites at the same time. The iteration loop with this stack is insanely fast, and so much work has been put into the framework and tools when I'm getting these google lighthouse scores out of the box for desktop and mobile. And subjectively, loading my site on my desktop or phone feels really fast
